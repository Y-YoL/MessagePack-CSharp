<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
    var targetTypes = new(string, string)[]
    {
        ("int", "int"),
        ("uint", "uint"),
        ("float", "float"),
        ("double", "double"),
        ("half", "half"),
    };
#>
// <auto-generated />

#if ENABLE_UNITY_MATHEMATICS
using System;
using MessagePack.Formatters;
using global::Unity.Mathematics;

namespace MessagePack.Unity.Mathematics
{
<#
    for (var i = 2; i <= 4; i++ ) {
        var properties = new[] { 'x', 'y', 'z', 'w' }
            .Take(i);
#>
    public abstract class Vector<#= i #>FormatterBase<TResult, TValue> : IMessagePackFormatter<TResult>
        where TResult : struct
        where TValue : struct
    {
        public abstract void Serialize(ref MessagePackWriter writer, TResult value, MessagePackSerializerOptions options);

        public TResult Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            TValue <#= string.Join(", ", properties) #>;
            var resolver = options.Resolver.GetFormatterWithVerify<TValue>();
            switch (reader.ReadArrayHeader())
            {
                case 1:
                    x = resolver.Deserialize(ref reader, options);
                    return Create(x);
                case <#= i #>:
<# foreach (var property in properties) { #>
                    <#= property #> = resolver.Deserialize(ref reader, options);
<# } #>
                    return Create(<#= string.Join(", ", properties) #>);
            }

            throw new InvalidOperationException();
        }
        
        protected abstract TResult Create(TValue x);
        protected abstract TResult Create(<#= string.Join(", ", properties.Select(v => $"TValue {v}")) #>);
    }

<# } #>
<#
    foreach ((var name, var element) in targetTypes) {
        for (var i = 2; i <= 4; i++ ) {
            var type = $"{name}{i}";
            var formatterName = $"{type.ToUpper()[0]}{string.Join("", type.Skip(1))}Formatter";
            var properties = new[] { 'x', 'y', 'z', 'w' }
                .Take(i);
#>
    public sealed class <#= formatterName #> : Vector<#= i #>FormatterBase<<#= $"{type}, {element}" #>>
    {
        public override void Serialize(ref MessagePackWriter writer, <#= type #> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.x);
            writer.Write(value.y);
        }

        protected override <#= type #> Create(<#= element #> x)
        {
            return new <#= type #>(x);
        }

        protected override <#= type #> Create(<#= string.Join(", ", properties.Select(v => $"{element} {v}")) #>)
        {
            return new <#= type #>(<#= string.Join(", ", properties) #>);
        }
    }

<#
        }
    }
#>
}
#endif
