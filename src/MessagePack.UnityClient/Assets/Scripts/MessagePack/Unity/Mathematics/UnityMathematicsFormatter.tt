<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
    var vectorTypes = new(string, string)[]
    {
        ("int", "int"),
        ("uint", "uint"),
        ("float", "float"),
        ("double", "double"),
        ("half", "half"),
    };

    var matrixTypes = new[]
    {
        "int",
        "uint",
        "float",
        "double",
    };
#>
// <auto-generated />

#if ENABLE_UNITY_MATHEMATICS
using System;
using System.Runtime.InteropServices;
using MessagePack.Formatters;
using global::Unity.Mathematics;

namespace MessagePack.Unity.Mathematics
{
<#
    // generate base vector formatter types
    for (var i = 2; i <= 4; i++ ) {
        var properties = GetProperties(i);
#>
    public abstract class Vector<#= i #>FormatterBase<TResult, TValue> : IMessagePackFormatter<TResult>
        where TResult : struct
        where TValue : struct
    {
        public abstract void Serialize(ref MessagePackWriter writer, TResult value, MessagePackSerializerOptions options);

        public TResult Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            TValue <#= string.Join(", ", properties) #>;
            var resolver = options.Resolver.GetFormatterWithVerify<TValue>();
            switch (reader.ReadArrayHeader())
            {
                case 1:
                    x = resolver.Deserialize(ref reader, options);
                    return Create(x);
                case <#= i #>:
<# foreach (var property in properties) { #>
                    <#= property #> = resolver.Deserialize(ref reader, options);
<# } #>
                    return Create(<#= string.Join(", ", properties) #>);
            }

            throw new InvalidOperationException();
        }

        protected abstract TResult Create(TValue x);
        protected abstract TResult Create(<#= string.Join(", ", properties.Select(v => $"TValue {v}")) #>);
    }

<# } #>
    public class MatrixFormatterBase<T>
        where T : struct
    {
        protected void Serialize(ref MessagePackWriter writer, ReadOnlySpan<T> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(value.Length);
            var formatter = options.Resolver.GetFormatterWithVerify<T>();
            foreach (var item in value)
            {
                formatter.Serialize(ref writer, item, options);
            }
        }

        protected void Deserialize(ref MessagePackReader reader, Span<T> value, int length, MessagePackSerializerOptions options)
        {
            var formatter = options.Resolver.GetFormatterWithVerify<T>();
            for (var i = 0; i < length; i++)
            {
                if (value.Length > i)
                {
                    value[i] = formatter.Deserialize(ref reader, options);
                }
                else
                {
                    reader.Skip();
                }
            }
        }
    }

<#
    // generate vector formatters each target types
    foreach ((var name, var element) in vectorTypes) {
        for (var i = 2; i <= 4; i++ ) {
            var type = $"{name}{i}";
            var formatterName = $"{type.ToUpper()[0]}{string.Join("", type.Skip(1))}Formatter";
            var properties = GetProperties(i);
#>
    public sealed class <#= formatterName #> : Vector<#= i #>FormatterBase<<#= $"{type}, {element}" #>>
    {
        public override void Serialize(ref MessagePackWriter writer, <#= type #> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.x);
            writer.Write(value.y);
        }

        protected override <#= type #> Create(<#= element #> x)
        {
            return new <#= type #>(x);
        }

        protected override <#= type #> Create(<#= string.Join(", ", properties.Select(v => $"{element} {v}")) #>)
        {
            return new <#= type #>(<#= string.Join(", ", properties) #>);
        }
    }

<#
        }
    }
#>
<#
    // generate base matrix formatter types
    foreach (var element in matrixTypes) {
        for (var i = 2; i <= 4; i++ ) {
            for (var j = 2; j <= 4; j++) {
                var properties = GetProperties(i);
                var type = $"{element}{i}x{j}";
                var formatterName = $"{type.ToUpper()[0]}{string.Join("", type.Skip(1))}Formatter";
#>
    public sealed class <#= formatterName #> : MatrixFormatterBase<<#= element #>>, IMessagePackFormatter<<#= type #>>
    {
        public void Serialize(ref MessagePackWriter writer, <#= type #> value, MessagePackSerializerOptions options)
        {
            var span = MemoryMarshal.CreateReadOnlySpan(ref value.c0.x, <#= i * j #>);
            base.Serialize(ref writer, span, options);
        }

        public <#= type #> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            switch (length)
            {
                case 1:
                    var formatter = options.Resolver.GetFormatterWithVerify<<#= element #>>();
                    var v = formatter.Deserialize(ref reader, options);
                    return new <#= type #>(v);
                default:
                    var value = default(<#= type #>);
                    var span = MemoryMarshal.CreateSpan(ref value.c0.x, <#= i * j #>);
                    base.Deserialize(ref reader, span, length, options);
                    return value;
            }
        }
    }

<#
            }
        }
    }
#>
}
#endif
<#+
    static IEnumerable<char> GetProperties(int length)
    {
        return new[] { 'x', 'y', 'z', 'w' }
            .Take(length);
    }
#>
